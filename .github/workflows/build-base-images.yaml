name: Build Base Docker Images

on:
  schedule:
    # Run weekly on Sundays at 00:00 UTC
    - cron: '0 0 * * 0'
  workflow_dispatch:
    inputs:
      images:
        description: 'Specific images to build (comma-separated, e.g., postgres,nginx) or "all" for all images'
        required: false
        default: 'all'

permissions:
  contents: read
  packages: write

env:
  REGISTRY: ghcr.io
  IMAGE_PREFIX: ${{ github.repository_owner }}

jobs:
  prepare:
    name: Prepare Build Matrix
    runs-on: ubuntu-latest
    outputs:
      matrix: ${{ steps.set-matrix.outputs.matrix }}
    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Set up build matrix
        id: set-matrix
        run: |
          IMAGES_INPUT="${{ github.event.inputs.images }}"
          
          # Define all available images with their versions
          # Format: image:version or just image (for single version)
          ALL_IMAGES='["kafka", "minio", "nginx", "postgres:17", "postgres:18", "redis"]'
          
          if [[ "$IMAGES_INPUT" == "all" ]] || [[ -z "$IMAGES_INPUT" ]]; then
            MATRIX="$ALL_IMAGES"
          else
            # Convert comma-separated input to JSON array
            # Support both "postgres" (builds all versions) and "postgres:17" (specific version)
            MATRIX=$(echo "$IMAGES_INPUT" | jq -R -c 'split(",") | map(gsub("^\\s+|\\s+$"; ""))')
          fi
          
          echo "matrix=$MATRIX" >> $GITHUB_OUTPUT
          echo "Building images: $MATRIX"

  build:
    name: Build ${{ matrix.image }}
    runs-on: ubuntu-latest
    needs: prepare
    strategy:
      fail-fast: false
      matrix:
        image: ${{ fromJson(needs.prepare.outputs.matrix) }}
        platform:
          - linux/amd64
          - linux/arm64
    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Parse image and version
        id: parse
        run: |
          IMAGE_FULL="${{ matrix.image }}"
          
          # Split image:version format
          if [[ "$IMAGE_FULL" == *":"* ]]; then
            IMAGE_NAME="${IMAGE_FULL%%:*}"
            IMAGE_VERSION="${IMAGE_FULL##*:}"
            CONTEXT_PATH="./scripts/dockerfiles/${IMAGE_NAME}/${IMAGE_VERSION}"
          else
            IMAGE_NAME="$IMAGE_FULL"
            IMAGE_VERSION=""
            CONTEXT_PATH="./scripts/dockerfiles/${IMAGE_NAME}"
          fi
          
          echo "name=$IMAGE_NAME" >> $GITHUB_OUTPUT
          echo "version=$IMAGE_VERSION" >> $GITHUB_OUTPUT
          echo "context=$CONTEXT_PATH" >> $GITHUB_OUTPUT
          echo "Parsed: name=$IMAGE_NAME, version=$IMAGE_VERSION, context=$CONTEXT_PATH"

      - name: Set up platform pair
        id: platform
        run: |
          PLATFORM_PAIR=$(echo "${{ matrix.platform }}" | sed 's/\//-/g')
          echo "pair=$PLATFORM_PAIR" >> $GITHUB_OUTPUT

      - name: Extract version from Dockerfile
        id: app-version
        run: |
          DOCKERFILE="${{ steps.parse.outputs.context }}/Dockerfile"
          IMAGE_NAME="${{ steps.parse.outputs.name }}"
          
          # If version is explicitly provided in matrix, use it
          if [[ -n "${{ steps.parse.outputs.version }}" ]]; then
            VERSION="${{ steps.parse.outputs.version }}"
          else
            # Extract version based on the image
            case "$IMAGE_NAME" in
              kafka)
                VERSION=$(grep -oP "kafka~\K[0-9]+" "$DOCKERFILE" || echo "3")
                ;;
              minio)
                VERSION=$(grep -oP "minio>=0\.\K[0-9]{4}" "$DOCKERFILE" || echo "2025")
                ;;
              nginx)
                VERSION=$(grep -oP "FROM openresty/openresty:\K[0-9]+\.[0-9]+\.[0-9]+\.[0-9]+" "$DOCKERFILE" || echo "1.27.1.2")
                ;;
              postgres)
                VERSION=$(grep -oP "postgresql-\K[0-9]+" "$DOCKERFILE" | head -1 || echo "17")
                ;;
              redis)
                VERSION=$(grep -oP "redis>=\K[0-9]+" "$DOCKERFILE" || echo "7")
                ;;
              *)
                VERSION="latest"
                ;;
            esac
          fi
          
          echo "version=$VERSION" >> $GITHUB_OUTPUT
          echo "Detected version for $IMAGE_NAME: $VERSION"

      - name: Docker meta
        id: meta
        uses: docker/metadata-action@v5
        with:
          images: ${{ env.REGISTRY }}/${{ env.IMAGE_PREFIX }}/${{ steps.parse.outputs.name }}
          tags: |
            type=raw,value=latest,enable=${{ matrix.image == 'postgres:18' || (matrix.image != 'postgres:17' && steps.parse.outputs.version == '') }}
            type=raw,value=${{ steps.app-version.outputs.version }}
            type=schedule,pattern={{date 'YYYYMMDD'}}
            type=sha,prefix={{date 'YYYYMMDD'}}-

      - name: Login to GitHub Container Registry
        uses: docker/login-action@v3
        with:
          registry: ${{ env.REGISTRY }}
          username: ${{ github.actor }}
          password: ${{ secrets.GITHUB_TOKEN }}

      - name: Set up Depot CLI
        uses: depot/setup-action@v1

      - name: Build and push by digest
        id: build
        uses: depot/build-push-action@v1
        with:
          project: ${{ secrets.DEPOT_PROJECT_ID }}
          token: ${{ secrets.DEPOT_TOKEN }}
          context: ${{ steps.parse.outputs.context }}
          platforms: ${{ matrix.platform }}
          labels: ${{ steps.meta.outputs.labels }}
          outputs: type=image,name=${{ env.REGISTRY }}/${{ env.IMAGE_PREFIX }}/${{ steps.parse.outputs.name }},push-by-digest=true,name-canonical=true,push=true

      - name: Export digest
        run: |
          mkdir -p /tmp/digests
          digest="${{ steps.build.outputs.digest }}"
          touch "/tmp/digests/${digest#sha256:}"

      - name: Upload digest
        uses: actions/upload-artifact@v4
        with:
          name: digests-${{ steps.parse.outputs.name }}-${{ steps.parse.outputs.version || 'latest' }}-${{ steps.platform.outputs.pair }}
          path: /tmp/digests/*
          if-no-files-found: error
          retention-days: 1

  merge:
    name: Merge ${{ matrix.image }} manifests
    runs-on: ubuntu-latest
    needs: [prepare, build]
    strategy:
      fail-fast: false
      matrix:
        image: ${{ fromJson(needs.prepare.outputs.matrix) }}
    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Parse image and version
        id: parse
        run: |
          IMAGE_FULL="${{ matrix.image }}"
          
          # Split image:version format
          if [[ "$IMAGE_FULL" == *":"* ]]; then
            IMAGE_NAME="${IMAGE_FULL%%:*}"
            IMAGE_VERSION="${IMAGE_FULL##*:}"
            CONTEXT_PATH="./scripts/dockerfiles/${IMAGE_NAME}/${IMAGE_VERSION}"
          else
            IMAGE_NAME="$IMAGE_FULL"
            IMAGE_VERSION=""
            CONTEXT_PATH="./scripts/dockerfiles/${IMAGE_NAME}"
          fi
          
          echo "name=$IMAGE_NAME" >> $GITHUB_OUTPUT
          echo "version=$IMAGE_VERSION" >> $GITHUB_OUTPUT
          echo "context=$CONTEXT_PATH" >> $GITHUB_OUTPUT
          echo "Parsed: name=$IMAGE_NAME, version=$IMAGE_VERSION, context=$CONTEXT_PATH"

      - name: Download digests
        uses: actions/download-artifact@v4
        with:
          path: /tmp/digests
          pattern: digests-${{ steps.parse.outputs.name }}-${{ steps.parse.outputs.version || 'latest' }}-*
          merge-multiple: true

      - name: Set up Docker Buildx
        uses: docker/setup-buildx-action@v3

      - name: Extract version from Dockerfile
        id: app-version
        run: |
          DOCKERFILE="${{ steps.parse.outputs.context }}/Dockerfile"
          IMAGE_NAME="${{ steps.parse.outputs.name }}"
          
          # If version is explicitly provided in matrix, use it
          if [[ -n "${{ steps.parse.outputs.version }}" ]]; then
            VERSION="${{ steps.parse.outputs.version }}"
          else
            # Extract version based on the image
            case "$IMAGE_NAME" in
              kafka)
                VERSION=$(grep -oP "kafka~\K[0-9]+" "$DOCKERFILE" || echo "3")
                ;;
              minio)
                VERSION=$(grep -oP "minio>=0\.\K[0-9]{4}" "$DOCKERFILE" || echo "2025")
                ;;
              nginx)
                VERSION=$(grep -oP "FROM openresty/openresty:\K[0-9]+\.[0-9]+\.[0-9]+\.[0-9]+" "$DOCKERFILE" || echo "1.27.1.2")
                ;;
              postgres)
                VERSION=$(grep -oP "postgresql-\K[0-9]+" "$DOCKERFILE" | head -1 || echo "17")
                ;;
              redis)
                VERSION=$(grep -oP "redis>=\K[0-9]+" "$DOCKERFILE" || echo "7")
                ;;
            *)
                VERSION="latest"
                ;;
            esac
          fi
          
          echo "version=$VERSION" >> $GITHUB_OUTPUT
          echo "Detected version for $IMAGE_NAME: $VERSION"

      - name: Docker meta
        id: meta
        uses: docker/metadata-action@v5
        with:
          images: ${{ env.REGISTRY }}/${{ env.IMAGE_PREFIX }}/${{ steps.parse.outputs.name }}
          tags: |
            type=raw,value=latest,enable=${{ matrix.image == 'postgres:18' || (matrix.image != 'postgres:17' && steps.parse.outputs.version == '') }}
            type=raw,value=${{ steps.app-version.outputs.version }}
            type=schedule,pattern={{date 'YYYYMMDD'}}
            type=sha,prefix={{date 'YYYYMMDD'}}-

      - name: Login to GitHub Container Registry
        uses: docker/login-action@v3
        with:
          registry: ${{ env.REGISTRY }}
          username: ${{ github.actor }}
          password: ${{ secrets.GITHUB_TOKEN }}

      - name: Create manifest list and push
        working-directory: /tmp/digests
        run: |
          docker buildx imagetools create $(jq -cr '.tags | map("-t " + .) | join(" ")' <<< "$DOCKER_METADATA_OUTPUT_JSON") \
            $(printf '${{ env.REGISTRY }}/${{ env.IMAGE_PREFIX }}/${{ steps.parse.outputs.name }}@sha256:%s ' *)

      - name: Inspect image
        run: |
          docker buildx imagetools inspect ${{ env.REGISTRY }}/${{ env.IMAGE_PREFIX }}/${{ steps.parse.outputs.name }}:${{ steps.app-version.outputs.version }}

  notify:
    name: Notify Build Status
    runs-on: ubuntu-latest
    needs: [prepare, build, merge]
    if: always()
    steps:
      - name: Alert Slack on Failure
        if: needs.build.result == 'failure' || needs.merge.result == 'failure'
        uses: rtCamp/action-slack-notify@v2
        env:
          SLACK_CHANNEL: foss
          SLACK_TITLE: "Failed ${{ github.workflow }}"
          SLACK_COLOR: failure
          SLACK_WEBHOOK: ${{ secrets.SLACK_WEB_HOOK }}
          SLACK_USERNAME: "OR Bot"
          SLACK_MESSAGE: "Base images build failed :bomb:"

      - name: Alert Slack on Success
        if: needs.build.result == 'success' && needs.merge.result == 'success'
        uses: rtCamp/action-slack-notify@v2
        env:
          SLACK_CHANNEL: foss
          SLACK_TITLE: "Success ${{ github.workflow }}"
          SLACK_COLOR: success
          SLACK_WEBHOOK: ${{ secrets.SLACK_WEB_HOOK }}
          SLACK_USERNAME: "OR Bot"
          SLACK_MESSAGE: "Base images built successfully :white_check_mark:"
