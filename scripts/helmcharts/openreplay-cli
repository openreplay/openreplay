#!/usr/bin/env bash
set -euo pipefail

readonly OR_DIR="/var/lib/openreplay"
readonly APP_NS="${APP_NS:-app}"
readonly DB_NS="${DB_NS:-db}"
readonly OR_REPO="${OR_REPO:-https://github.com/openreplay/openreplay}"

readonly RED='\033[0;31m'
readonly GREEN='\033[0;32m'
readonly YELLOW='\033[0;33m'
readonly BWHITE='\033[1;37m'
readonly NC='\033[0m'

readonly TOOLS=(
    zyedidia/eget
    stern/stern
    hidetatz/kubecolor
    rjshrjndrn/templater
)

initialize_environment() {
    [[ -d "$OR_DIR" ]] || sudo mkdir -p "$OR_DIR"
    export PATH="$OR_DIR:$PATH"

    local architecture
    architecture=$(uname -m)
    case "$architecture" in
    x86_64)
        echo "AMD (x86_64) architecture detected"
        PKG_TYPE="amd64"
        ;;
    aarch64)
        echo "ARM architecture detected"
        PKG_TYPE="arm64"
        ;;
    *)
        echo "Unsupported architecture: $architecture"
        exit 1
        ;;
    esac
    readonly PKG_TYPE

    [[ $(awk '/enterpriseEditionLicense/{print $2}' <"$OR_DIR/vars.yaml" 2>/dev/null) != "" ]] && readonly EE=true || readonly EE=false

    setup_kubeconfig
    readonly TMP_DIR=$(mktemp -d)
}

setup_kubeconfig() {
    local k3s_path=""
    [[ -f /etc/rancher/k3s/k3s.yaml ]] && k3s_path="/etc/rancher/k3s/k3s.yaml"
    [[ -f "${HOME}/.kube/config" ]] && k3s_path="${k3s_path:-${HOME}/.kube/config}"

    export KUBECONFIG="${KUBECONFIG:-$k3s_path}"

    if [[ -z "${KUBECONFIG:-}" ]]; then
        log warn "No kubeconfig file found"
        return 1
    fi

    log info "Using KUBECONFIG: $KUBECONFIG"
}

log() {
    local level="$1"
    shift

    case "$level" in
    info)
        echo -e "${GREEN}[INFO]${NC}" "$@"
        ;;
    warn)
        echo -e "${YELLOW}[WARN]${NC}" "$@"
        ;;
    debug)
        echo -e "${YELLOW}[DEBUG]${NC}" "$@"
        ;;
    title)
        echo -e "\n${BWHITE}-${NC}" "$@"
        ;;
    err)
        echo -e "${RED}[ERROR]${NC}" "$@" >&2
        exit 100
        ;;
    *)
        echo "Unsupported log format: $level" >&2
        exit 100
        ;;
    esac
}

err_cd() {
    if ! cd "$1" &>/dev/null; then
        log err "Failed to change directory to: $1"
    fi
}

check_failed_pod_logs() {
    echo -e "${RED}Checking failed pod logs...${NC}"

    local pods
    pods=$(kubectl get pods -n "$APP_NS" --field-selector=status.phase=Failed -o jsonpath='{.items[*].metadata.name}' 2>/dev/null || echo "")

    if [[ -z "$pods" ]]; then
        echo "No failed pods found"
        return
    fi

    for pod in $pods; do
        local containers
        containers=$(kubectl get pod "$pod" -n "$APP_NS" -o jsonpath='{.status.containerStatuses[?(@.state.terminated.reason=="Error")].name} {.status.initContainerStatuses[?(@.state.terminated.reason=="Error")].name}' 2>/dev/null || echo "")

        for container in $containers; do
            echo "Error logs for Pod: $pod, Container: $container"
            kubectl logs -n "$APP_NS" "$pod" -c "$container" 2>/dev/null || echo "Failed to fetch logs"
        done
    done
    echo -e "${NC}"
}

install_packages() {
    log title "Installing/Updating packages"

    if [[ ! -e "$OR_DIR/eget" ]]; then
        local temp_dir
        temp_dir=$(mktemp -d)
        pushd "$temp_dir" >/dev/null || log err "Failed to create temp directory"

        if ! command -v curl &>/dev/null; then
            log err "curl not found. Please install curl"
        fi

        curl -SsL https://zyedidia.github.io/eget.sh | sh - >/dev/null
        sudo mv eget "$OR_DIR"
        popd >/dev/null
        rm -rf "$temp_dir"
    fi

    for package in "${TOOLS[@]}"; do
        local pkg_name
        pkg_name=$(basename "$package")
        log info "Installing $pkg_name"
        sudo "$OR_DIR/eget" -q --upgrade-only --to "$OR_DIR" "$package"
    done

    log info "Installing k9s"
    sudo "$OR_DIR/eget" -q --upgrade-only --to "$OR_DIR" derailed/k9s --asset=tar.gz --asset=^sbom

    log info "Installing yq"
    sudo "$OR_DIR/eget" -q --upgrade-only --to "$OR_DIR" mikefarah/yq --asset=^tar.gz

    log info "Installing helm"
    sudo "$OR_DIR/eget" -q --upgrade-only --to "$OR_DIR" "https://get.helm.sh/helm-v3.10.2-linux-${PKG_TYPE}.tar.gz" -f helm

    log info "Installing kubectl"
    sudo "$OR_DIR/eget" -q --upgrade-only --to "$OR_DIR" "https://dl.k8s.io/release/v1.25.0/bin/linux/${PKG_TYPE}/kubectl"

    date | sudo tee "$OR_DIR/packages.lock" &>/dev/null

    if ! grep -q "/var/lib/openreplay" /etc/profile 2>/dev/null; then
        echo 'export PATH=/var/lib/openreplay:$PATH' | sudo tee -a /etc/profile >/dev/null
    fi
}

show_help() {
    echo -e "${BWHITE}"
    cat <<"EOF"
  ___                   ____            _
 / _ \ _ __   ___ _ __ |  _ \ ___ _ __ | | __ _ _   _
| | | | '_ \ / _ \ '_ \| |_) / _ \ '_ \| |/ _` | | | |
| |_| | |_) |  __/ | | |  _ <  __/ |_) | | (_| | |_| |
 \___/| .__/ \___|_| |_|_| \_\___| .__/|_|\__,_|\__, |
      |_|                        |_|            |___/
EOF
    echo -e "${NC}"

    log info "
  Usage: openreplay [ -h | --help ]
                    [ -s | --status ]
                    [ -i | --install DOMAIN_NAME ]
                    [ -u | --upgrade ]
                    [ -r | --restart ]
                    [ -R | --reload ]
                    [ -c | --cleanup N (days) [--force] ]
                    [ -e | --edit ]
                    [ -p | --install-packages ]
                    [ -l | --logs SERVICE ]

  Options:
    -h, --help                  Show this help message
    -s, --status                Check OpenReplay components status
    -i, --install DOMAIN        Install OpenReplay
    -u, --upgrade               Upgrade OpenReplay (use RELEASE_UPGRADE=1 for release upgrade)
    -r, --restart               Restart all OpenReplay components
    -R, --reload                Reload OpenReplay components
    -c, --cleanup N             Clean up data older than N days
    -e, --edit                  Edit configuration file
    -p, --install-packages      Install/update dependency packages
    -l, --logs SERVICE          Show logs for a service

  Environment Variables:
    OR_VERSION                  Specify branch/tag to install (default: main)
    RELEASE_UPGRADE=1           Perform major release upgrade
    UPGRADE_OR_ONLY=1           Upgrade only OpenReplay, skip toolings
    OVERRIDE_FILE               Path to vars.yaml override file
    CLEANUP_TOOLING=1           Remove toolings chart during upgrade

  Services: alerts, assets, assist, chalice, db, ender, frontend,
           heuristics, http, integrations, nginx-controller, peers,
           sink, sourcemapreader, storage

  Note: Repository is maintained at $OR_DIR/openreplay_repo using sparse
        checkout (scripts/helmcharts only) to minimize disk usage.
    "
}

show_status() {
    log info "OpenReplay Version"
    yq eval '.config.version // .fromVersion' "$OR_DIR/vars.yaml" 2>/dev/null || echo "N/A"

    log info "Repository Info"
    if [[ -d "$OR_DIR/openreplay_repo/.git" ]]; then
        local repo_branch repo_commit repo_size
        repo_branch=$(cd "$OR_DIR/openreplay_repo" && git rev-parse --abbrev-ref HEAD 2>/dev/null || echo "unknown")
        repo_commit=$(cd "$OR_DIR/openreplay_repo" && git rev-parse --short HEAD 2>/dev/null || echo "unknown")
        repo_size=$(du -sh "$OR_DIR/openreplay_repo" 2>/dev/null | cut -f1 || echo "unknown")
        echo "  Branch: $repo_branch"
        echo "  Commit: $repo_commit"
        echo "  Size: $repo_size"
    else
        echo "  Repository not cloned yet"
    fi

    log info "Disk Usage"
    df -h /var

    log info "Memory"
    free -mh

    log info "CPU"
    echo "CPU Count: $(nproc)"
    awk '(NR<2)' /etc/os-release 2>/dev/null
    uname -a

    log info "Kubernetes"
    kubecolor version --short 2>/dev/null || kubectl version --short

    log info "OpenReplay Components"
    kubecolor get po -n "$APP_NS" 2>/dev/null || kubectl get po -n "$APP_NS"
    kubecolor get po -n "$DB_NS" 2>/dev/null || kubectl get po -n "$DB_NS"

    echo
    log info "OpenReplay Images"
    echo
    kubectl get pods -n "$APP_NS" -o jsonpath='{range .items[*]}{@.metadata.name}{" "}{@.spec.containers[*].image}{"\n"}{end}' 2>/dev/null | column -t
    kubectl get pods -n "$DB_NS" -o jsonpath='{range .items[*]}{@.metadata.name}{" "}{@.spec.containers[*].image}{"\n"}{end}' 2>/dev/null | column -t
}

patch_version() {
    local version
    version=$("$OR_DIR/yq" '.fromVersion' vars.yaml)-$(git rev-parse --short HEAD 2>/dev/null || echo "unknown")

    cat <<EOF >/tmp/version_snippet.yaml
config:
  version: $version
EOF

    sudo "$OR_DIR/yq" eval-all 'select(fileIndex == 0) * select(fileIndex == 1)' vars.yaml /tmp/version_snippet.yaml -i
    rm -f /tmp/version_snippet.yaml
}

helm_upgrade_openreplay() {
    set -o pipefail
    local state="${1:-}"
    local log_file="${TMP_DIR}/helm.log"
    local chart_names=(toolings openreplay)

    [[ "${UPGRADE_OR_ONLY:-0}" -eq 1 ]] && chart_names=(openreplay)
    [[ "${CLEANUP_TOOLING:-0}" -eq 1 ]] && helm uninstall toolings -n "$APP_NS" 2>/dev/null || true

    if [[ "$state" == "reload" ]]; then
        chart_names=(openreplay)
        HELM_OPTIONS="${HELM_OPTIONS:-} --set skipMigration=true"
    fi

    for chart in "${chart_names[@]}"; do
        [[ -n "${OR_VERSION:-}" ]] && HELM_OPTIONS="${HELM_OPTIONS:-} --set dbMigrationUpstreamBranch=${OR_VERSION}"

        log info "Upgrading chart: $chart"

        if ! helm upgrade --install "$chart" "./$chart" -n "$APP_NS" --wait -f ./vars.yaml --atomic --debug ${HELM_OPTIONS:-} 2>&1 | tee -a "$log_file"; then
            check_failed_pod_logs
            log err "Installation failed. Check logs at: ${BWHITE}${log_file}${RED}
            
Run ${BWHITE}openreplay --status${RED} for more info
Run ${BWHITE}openreplay --logs <service-name>${RED} to view specific logs"
        fi
    done

    set +o pipefail
}

clone_repository() {
    local repo_dir="$OR_DIR/openreplay_repo"
    local ref="${OR_VERSION:-main}"

    if [[ -d "$repo_dir/.git" ]]; then
        log info "Repository exists, updating to: $ref"
        err_cd "$repo_dir"

        git fetch origin --depth 1 "$ref" 2>&1 || log err "Failed to fetch $ref"

        git reset --hard 2>&1 || log warn "Failed to reset working directory"
        git clean -fd 2>&1 || log warn "Failed to clean untracked files"

        if git show-ref --verify --quiet "refs/remotes/origin/$ref"; then
            log info "Checking out branch: $ref"
            git checkout "$ref" 2>&1 || log err "Failed to checkout branch $ref"
            git reset --hard "origin/$ref" 2>&1 || log err "Failed to reset to origin/$ref"
        else
            log info "Checking out tag/commit: $ref"
            git checkout "$ref" 2>&1 || log err "Failed to checkout $ref"
        fi

        git sparse-checkout reapply 2>&1 || log warn "Failed to reapply sparse checkout"

        git gc --prune=now --aggressive 2>&1 || log warn "Failed to cleanup git repository"
    else
        log info "Performing sparse checkout (scripts/helmcharts only)..."
        sudo mkdir -p "$repo_dir"
        sudo chown -R "$(whoami):$(id -gn)" "$repo_dir"
        err_cd "$repo_dir"

        git clone --filter=blob:none --sparse --depth 1 --branch "$ref" "$OR_REPO" . 2>&1 || log err "Failed to clone repository"
        git sparse-checkout set scripts/helmcharts 2>&1 || log err "Failed to configure sparse checkout"
    fi

    if [[ ! -f "$repo_dir/scripts/helmcharts/vars.yaml" ]]; then
        log err "vars.yaml not found after checkout at: $repo_dir/scripts/helmcharts/
        
Directory contents:
$(ls -la "$repo_dir/scripts/helmcharts/" 2>&1 || echo "Directory not found")

Try removing the repository and running upgrade again:
  ${BWHITE}sudo rm -rf $OR_DIR/openreplay_repo${RED}"
    fi

    local repo_size current_ref
    repo_size=$(du -sh "$repo_dir" 2>/dev/null | cut -f1 || echo "unknown")
    current_ref=$(git describe --tags --always 2>/dev/null || git rev-parse --short HEAD 2>/dev/null || echo "unknown")

    log info "Repository size: $repo_size"
    log info "Current ref: $current_ref"
    log info "Using charts from: $repo_dir/scripts/helmcharts"
}

sem_to_int() {
    echo "$1" | awk -F'[v.]' '{print $2 $3 $4 + 0}'
}

version_specific_checks() {
    local version
    version=$(sem_to_int "$1")

    if [ "$version" -le 1220 ]; then
        log info "Checking version-specific requirements (v$1)"

        if [ -z "$(kubectl get pods -n "$DB_NS" -l app.kubernetes.io/name=clickhouse --no-headers 2>/dev/null)" ]; then
            log info "Installing ClickHouse"
            kubectl apply -f https://github.com/openreplay/openreplay/raw/refs/heads/main/scripts/helmcharts/manifests/clickhouse-db.yaml -n "$DB_NS"
        fi
    fi
}

install_openreplay() {
    local domain_name="$1"

    if [[ -f "$OR_DIR/vars.yaml" ]]; then
        local existing_version
        existing_version=$(awk '/fromVersion/{print $2}' <"$OR_DIR/vars.yaml")
        log err "OpenReplay ${BWHITE}${existing_version}${RED} already installed. Use ${BWHITE}openreplay -u${RED} to upgrade"
    fi

    install_packages
    log title "Installing OpenReplay"
    clone_repository
    err_cd "$OR_DIR/openreplay_repo/scripts/helmcharts"

    if [[ -n "${OVERRIDE_FILE:-}" ]]; then
        if [[ ! -f "$OVERRIDE_FILE" ]]; then
            log err "Override file not found: $OVERRIDE_FILE"
        fi

        local override_dir
        override_dir=$(pwd)
        pushd /tmp >/dev/null
        cp "$OVERRIDE_FILE" new_vars.yaml
        cp "$override_dir/vars.yaml" old_vars.yaml
        yq '(load("new_vars.yaml") | .. | select(tag != "!!map" and tag != "!!seq")) as $i ireduce(.; setpath($i | path; $i))' old_vars.yaml >vars.yaml
        mv vars.yaml "$override_dir"
        popd >/dev/null
    fi

    [[ -n "${OR_VERSION:-}" ]] && HELM_OPTIONS="${HELM_OPTIONS:-} --set dbMigrationUpstreamBranch=${OR_VERSION}"

    HELM_OPTIONS="${HELM_OPTIONS:-}" SKIP_K8S_TOOLS=1 DOMAIN_NAME="$domain_name" bash init.sh
}

cleanup_data() {
    local days="$1"
    local force="${2:-}"
    local delete_date
    delete_date=$(date +%Y-%m-%d -d "$days day ago")

    if [[ "$force" != "--force" ]]; then
        log debug "Delete data captured on/before ${BWHITE}${delete_date}${YELLOW}?"
        read -p "Are you sure [y/n]? " -n 1 -r
        echo
        if [[ ! $REPLY =~ ^[Yy]$ ]]; then
            log warn "Data deletion cancelled"
            return 1
        fi
    fi

    log info "Starting cleanup process..."

    local pguser pgpassword pghost pgport pgdatabase
    pguser=$(yq 'explode(.) | .global.postgresql.postgresqlUser' "$OR_DIR/vars.yaml")
    pgpassword=$(yq 'explode(.) | .global.postgresql.postgresqlPassword' "$OR_DIR/vars.yaml")
    pghost=$(yq 'explode(.) | .global.postgresql.postgresqlHost' "$OR_DIR/vars.yaml")
    pgport=$(yq 'explode(.) | .global.postgresql.postgresqlPort' "$OR_DIR/vars.yaml")
    pgdatabase=$(yq 'explode(.) | .global.postgresql.postgresqlDatabase' "$OR_DIR/vars.yaml")

    local cleanup_query="DELETE FROM public.sessions WHERE start_ts < extract(epoch from '${delete_date}'::date) * 1000;"

    if [[ "$EE" == "true" ]]; then
        cleanup_query="DELETE FROM public.sessions WHERE start_ts < extract(epoch from '${delete_date}'::date) * 1000 AND session_id NOT IN (SELECT session_id FROM user_favorite_sessions);"
    fi

    kubectl delete po -n "$APP_NS" pg-cleanup &>/dev/null || true
    kubectl run pg-cleanup -n "$APP_NS" \
        --restart=Never \
        --env PGHOST="$pghost" \
        --env PGUSER="$pguser" \
        --env PGDATABASE="$pgdatabase" \
        --env PGPASSWORD="$pgpassword" \
        --env PGPORT="$pgport" \
        --image bitnami/postgresql -- psql -c "$cleanup_query"

    local minio_access_key minio_secret_key minio_host
    minio_access_key=$(yq 'explode(.) | .global.s3.accessKey' "$OR_DIR/vars.yaml")
    minio_secret_key=$(yq 'explode(.) | .global.s3.secretKey' "$OR_DIR/vars.yaml")
    minio_host=$(yq 'explode(.) | .global.s3.endpoint' "$OR_DIR/vars.yaml")

    kubectl delete po -n "$APP_NS" minio-cleanup &>/dev/null || true
    kubectl run minio-cleanup -n "$APP_NS" \
        --restart=Never \
        --env MINIO_HOST="$minio_host" \
        --image bitnami/minio:2020.10.9-debian-10-r6 -- /bin/sh -c "
      mc alias set minio $minio_host $minio_access_key $minio_secret_key &&
      mc rm --recursive --dangerous --force --older-than ${days}d minio/mobs"

    log info "Postgres cleanup initiated. Vacuum will run automatically when database is idle."
    log info "MinIO cleanup initiated."
    log info "Run ${BWHITE}openreplay -s${GREEN} to check cleanup status and disk space."
}

upgrade_openreplay() {
    if [[ ! -f "$OR_DIR/vars.yaml" ]]; then
        log err "Configuration file not found: ${BWHITE}${OR_DIR}/vars.yaml${RED}"
    fi

    if ! command -v git &>/dev/null; then
        log err "git not found. Please install git"
    fi

    local or_version
    or_version=$(yq eval '.fromVersion' "$OR_DIR/vars.yaml")

    if [[ "${RELEASE_UPGRADE:-0}" -eq 1 ]]; then
        version_specific_checks "$or_version"
    else
        OR_VERSION="${OR_VERSION:-$or_version}"
    fi

    clone_repository
    install_packages

    err_cd "$OR_DIR/openreplay_repo/scripts/helmcharts"

    [[ -d /openreplay ]] && sudo chown -R 1001:1001 /openreplay

    cp "$OR_DIR/vars.yaml" old_vars.yaml
    local or_new_version
    or_new_version=$(awk '/fromVersion/{print $2}' <vars.yaml)

    yq '(load("old_vars.yaml") | .. | select(tag != "!!map" and tag != "!!seq")) as $i ireduce(.; setpath($i | path; $i))' vars.yaml >new_vars.yaml
    mv new_vars.yaml vars.yaml
    templater -i vars.yaml -o vars.yaml

    helm_upgrade_openreplay

    sed -i "s/fromVersion.*/fromVersion: ${or_new_version}/" vars.yaml
    patch_version

    sudo mv ./openreplay-cli /bin/openreplay
    sudo chmod +x /bin/openreplay
    sudo mv ./vars.yaml "$OR_DIR"

    log info "Configuration saved to: /var/lib/openreplay/vars.yaml"
    log info "Run ${BWHITE}openreplay -h${GREEN} for CLI help"
}

reload_components() {
    if [[ ! -d "$OR_DIR/openreplay_repo/scripts/helmcharts" ]]; then
        log err "Repository not found. Please run upgrade first."
    fi

    err_cd "$OR_DIR/openreplay_repo/scripts/helmcharts"
    sudo cp -f "$OR_DIR/vars.yaml" .
    helm_upgrade_openreplay reload
}

edit_configuration() {
    if [[ ! -f "$OR_DIR/vars.yaml" ]]; then
        log err "Configuration file not found: ${BWHITE}${OR_DIR}/vars.yaml${RED}
        
Edit your vars.yaml and run: ${BWHITE}openreplay -R${RED}"
    fi

    local checksum_file="${TMP_DIR}/vars.yaml.md5"
    md5sum "$OR_DIR/vars.yaml" >"$checksum_file"

    sudo vim -n "$OR_DIR/vars.yaml"

    if ! "$OR_DIR/yq" 'true' "$OR_DIR/vars.yaml" &>/dev/null; then
        log debug "Invalid YAML syntax. Run ${BWHITE}openreplay -e${YELLOW} to fix"
        return 1
    fi

    if md5sum -c "$checksum_file" &>/dev/null; then
        log info "No changes detected in configuration"
    else
        reload_components
    fi
}

restart_deployments() {
    log title "Restarting OpenReplay Components"
    kubecolor rollout restart deployment -n "$APP_NS" 2>/dev/null || kubectl rollout restart deployment -n "$APP_NS"
    kubecolor rollout status deployment -n "$APP_NS" 2>/dev/null || kubectl rollout status deployment -n "$APP_NS"
}

view_logs() {
    local service="$1"
    stern -A --container-state=running,terminated $service
}

cleanup_temp_dir() {
    [[ -z "${SKIP_DELETE_TMP_DIR:-}" ]] && rm -rf "$TMP_DIR"
}

main() {
    initialize_environment

    if [[ ! -f "$OR_DIR/packages.lock" ]]; then
        log title "Installing packages"
        install_packages
    fi

    if [[ $# -eq 0 ]]; then
        show_help
        cleanup_temp_dir
        exit 0
    fi

    local parsed_args
    if ! parsed_args=$(getopt -a -n openreplay -o Rrevpi:uhsl:c: --long reload,edit,restart,verbose,install-packages,install:,upgrade,help,status,logs:,cleanup:,force -- "$@"); then
        show_help
        exit 1
    fi

    eval set -- "$parsed_args"

    while true; do
        case "$1" in
        -h | --help)
            show_help
            cleanup_temp_dir
            exit 0
            ;;
        -i | --install)
            log title "Installing OpenReplay"
            install_openreplay "$2"
            cleanup_temp_dir
            exit 0
            ;;
        -p | --install-packages)
            log title "Installing/Updating packages"
            install_packages
            cleanup_temp_dir
            exit 0
            ;;
        -u | --upgrade)
            if [[ "${RELEASE_UPGRADE:-0}" -eq 1 ]]; then
                log title "Upgrading to Latest Release"
                CLEANUP_TOOLING=1
            else
                log title "Applying Latest Patches"
                UPGRADE_OR_ONLY="${UPGRADE_OR_ONLY:-1}"
            fi
            upgrade_openreplay
            cleanup_temp_dir
            exit 0
            ;;
        -c | --cleanup)
            log title "Cleaning up data older than $2 days"
            cleanup_data "$2" "${3:-}"
            cleanup_temp_dir
            exit 0
            ;;
        -r | --restart)
            restart_deployments
            cleanup_temp_dir
            exit 0
            ;;
        -R | --reload)
            log title "Reloading OpenReplay"
            reload_components
            cleanup_temp_dir
            exit 0
            ;;
        -e | --edit)
            log title "Editing Configuration"
            edit_configuration
            cleanup_temp_dir
            exit 0
            ;;
        -s | --status)
            log title "OpenReplay Status"
            show_status
            cleanup_temp_dir
            exit 0
            ;;
        -l | --logs)
            view_logs "$2"
            cleanup_temp_dir
            exit 0
            ;;
        -v | --verbose)
            set -x
            shift
            ;;
        --)
            shift
            break
            ;;
        *)
            echo "Unexpected option: $1"
            show_help
            cleanup_temp_dir
            exit 1
            ;;
        esac
    done

    cleanup_temp_dir
}

trap cleanup_temp_dir EXIT

main "$@"
